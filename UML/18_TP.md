### Objectif du TP 

Faire évoluer une petite application Java simple en introduisant progressivement des Design Patterns.

Voici une mini-application de calcul de réduction sur un prix selon le type de client :

```java
public class CalculateurPrix {
    public double calculerPrix(double prix, String typeClient) {
        if (typeClient.equals("ETUDIANT")) {
            return prix * 0.8;
        } else if (typeClient.equals("VIP")) {
            return prix * 0.7;
        } else {
            return prix;
        }
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        CalculateurPrix calculateur = new CalculateurPrix();
        System.out.println("Prix étudiant : " + calculateur.calculerPrix(100, "ETUDIANT"));
        System.out.println("Prix VIP : " + calculateur.calculerPrix(100, "VIP"));
    }
}
```

Un des problèmes majeurs de ce code est que si l'on veut ajouter un nouveau type de client on doit modifier du code : pas ouvert à l'extension. 

### Partie 1 (30 minutes)

L'objectif est d'isoler les politiques de calcul dans des stratégies interchangeables. 

En utilisant un design pattern particulier :

1. Créer une interface StrategieReduction
2. Implémenter plusieurs stratégies concrètes
3. Injecter dynamiquement la stratégie dans le calculateur

### Partie 2 (30 minutes)

L’entreprise veut maintenant afficher ou journaliser les calculs effectués sans modifier le calculateur.
L'objectif est donc de notifier automatiquement une interface ou un journal lorsqu’un calcul est effectué.

En utilisant un design pattern particulier :

1. Introduire un sujet observable (CalculateurPrix)
2. Ajouter des observateurs (ex : AfficheurConsole, JournalFichier)

Lorsqu’un calcul est fait les observateurs sont notifiés et implémentent un comportement respectif. 
AfficheurConsole = affichage dans la console
JournalFichier = écriture dans un fichier txt
